<html>
  <head>
    <link rel="stylesheet" href="./style.css" />
  </head>

  <body>
    <h1>Project 2</h1>
    Isabel Li
    <br /><br />
    <hr />
    <br />
    <h2>Overview</h2>
    <p>
      De Casteljau's algorithm is a recursive method used to evaluate Bezier
      curves. Through repeated linear interpolation, the algorithm allows us to
      find a point which lies on the Bezier curve at a given parameter <i>t</i>,
      where <i>t</i> is between 0 and 1.
    </p>

    <h2>Part 1: Bezier Curves with 1D de Casteljau Subdivision</h2>
    <p>
      De Casteljau's algorithm is a recursive method used to evaluate Bezier
      curves. Through repeated linear interpolation, the algorithm allows us to
      find a point which lies on the Bezier curve at a given parameter <i>t</i>,
      where <i>t</i> is between 0 and 1.
    </p>
    <p>
      Given <i>n</i> control points <i>p<sub>1</sub></i
      >, ..., <i>p<sub>n</sub></i> and the parameter <i>t</i>, De Casteljau's
      algorithm uses linear interpolation to compute <i>n</i> - 1 intermediate
      control points at <i>t</i> in the next subdivision level. These are
      <i>p'<sub>1</sub></i
      >, ..., <i>p'<sub>n-1</sub></i
      >, where <i>p'<sub>i</sub></i> = (1-<i>t</i>) <i>p<sub>i</sub></i> +
      <i>tp<sub>i+1</sub></i
      >.
    </p>

    <p>
      This is applied <i>n</i> - 1 times on the previous subdivision level until
      producing a final singular point which lies on the Bezier curve at
      <i>t</i>.
    </p>

    <p>
      In this part, I implemented one level of the algorithm (one level of
      subdivision) in a function which took in an array of control points and
      returned an array of control points at the next subdivision level. I
      iterated through the argument array and applied the lerp function for
      <i>p'<sub>i</sub></i> described above, before pushing this to an array of
      the new control points.
    </p>
    <br />
    <div class="col2">
      <div>
        <img src="./p1_1.png" width="95%" id="figure" />
        <figcaption>Unevaluated curve</figcaption>
      </div>

      <div>
        <img src="./p1_2.png" width="95%" id="figure" />
        <figcaption>Step 1 of evaluation</figcaption>
      </div>
    </div>

    <div class="col2">
      <div>
        <img src="./p1_3.png" width="95%" id="figure" />
        <figcaption>Step 2 of evaluation</figcaption>
      </div>

      <div>
        <img src="./p1_4.png" width="95%" id="figure" />
        <figcaption>Step 3 of evaluation</figcaption>
      </div>
    </div>

    <div class="col2">
      <div>
        <img src="./p1_5.png" width="95%" id="figure" />
        <figcaption>Step 4 of evaluation</figcaption>
      </div>

      <div>
        <img src="./p1_6.png" width="95%" id="figure" />
        <figcaption>(Final) step 5 of evaluation</figcaption>
      </div>
    </div>

    <img src="./p1_7.png" width="100%" id="figure" />
    <figcaption>Completed Bezier curve</figcaption>

    <img src="./p1_8.png" width="100%" id="figure" />
    <figcaption>
      Slightly modified Bezier curve with moved control points and modified
      <i>t</i> parameter.
    </figcaption>

    <br />
    <br />

    <h2>Part 2: Bezier Surfaces with Separable 1D de Casteljau</h2>
    <p>
      The De Casteljau algorithm extends to Bezier surfaces through the
      separable 1D De Casteljau algorithm. The algorithm described above is
      applied to a <i>n</i> * <i>n</i> grid of original control points, with
      parameters <i>u</i> and <i>v</i>.
    </p>
    <p>
      Each row of <i>n</i> control points defines a Bezier curve parameterised
      by <i>u</i>; the respective final, single point <i>P<sub>i</sub></i> is
      evaluated recursively for each of <i>n</i> rows using the algorithm in
      part 1, with <i>u</i> as the argument <i>t</i>.
    </p>

    <p>
      The <i>n</i> <i>P<sub>i</sub></i
      >'s for each of the <i>n</i> rows then define a Bezier curve with
      parameter <i>v</i>. This is also then evaluated recursively with De
      Casteljau's to produce a final singular point which lies on the Bezier
      surface for given parameters <i>u</i> and <i>v</i>.
    </p>

    <p></p>
    <img src="./p1_9.png" width="100%" id="figure" />
    <figcaption>
      Screenshot of <code>bez/teapot.bez</code> evaluated by my implementation
    </figcaption>
    <br />
    <br />

    <h2>Part 3: Area-Weighted Vertex Normals</h2>
    <p>
      I implemented area-weighted normal vectors at a vertex by iterating
      through neighbouring vertices, storing two vertex positions <i>A</i> and
      <i>B</i> at a time, in addition to the original vertex position <i>C</i>.
      Using these three vertices, I found vectors <i>C - A</i> and <i>C - B</i>,
      and used their cross product to calculate the normal to the face.
    </p>

    <p>
      I then found the area-weighted normal by dividing this cross product by
      0.5 * its magnitude, and pushed the area-weighted normal to an array of
      all weighted normals. I repeated this process for each face incident to
      the vertex. To find the final vector normal, I summed the weighted normals
      within the array, and divided this summed vector by its own magnitude.
    </p>
    <div class="col2">
      <div>
        <img src="./p10.png" width="95%" id="figure" />
        <figcaption>
          Screenshot of <code>dae/teapot.dae</code> without vertex normals
          (default flat shading)
        </figcaption>
      </div>

      <div>
        <img src="./p11.png" width="95%" id="figure" />
        <figcaption>
          Screenshot of <code>dae/teapot.dae</code> with vertex normals (Phong
          shading)
        </figcaption>
      </div>
    </div>

    <p></p>
    <br />
    <br />

    <h2>Part 4: Edge Flip</h2>
    <p>
      To implement edge flipping, I initiated pointers to every half-edge, face,
      and vertex. I then reassigned all the half-edges' next, twin, vertex,
      edge, and face pointers according to the flipped result -- I kept the
      vertices and halfedges on the sides of the external "diamond" in the same
      position, but re-assigned the pointer to edge (<i>b</i>, <i>c</i>) to the
      vertices <i>a</i> and <i>d</i>. The faces (<i>a</i>, <i>b</i>, <i>c</i>)
      and (<i>b</i>, <i>c</i>, <i>d</i>) then became (<i>a</i>, <i>c</i>,
      <i>d</i>) and (<i>a</i>, <i>b</i>, <i>d</i>) respectively, and I
      reassigned the corresponding halfedges based on any face changes. I
      implemented a check at the beginning of the function to return if the
      element is at a boundary.
    </p>

    <img src="./p14.png" width="95%" />

    <p>
      Regarding debugging, my implementation was close to correct on my initial
      attempt. My "debugging" process mostly consisted of re-reading the
      assignments for each mesh element, and then catching and correcting some
      assignments which didn't make sense to me upon the second read.
    </p>
    <div class="col2">
      <div>
        <img src="./p13.png" width="95%" id="figure" />
        <figcaption>
          Screenshot of <code>dae/teapot.dae</code> before edge flips
        </figcaption>
      </div>

      <div>
        <img src="./p12.png" width="95%" id="figure" />
        <figcaption>
          Screenshot of <code>dae/teapot.dae</code> after some edge flips
        </figcaption>
      </div>
    </div>

    <br />
    <br />

    <h2>Part 5: Edge Split</h2>
    <p>
      For this part, my implementation process was very similar to my
      implementation of edge flips. I initiated pointers to every relevant mesh
      element (vertices, faces, halfedges) and re-assigned all their pointers
      according to the "after split" diagram, including to newly created mesh
      elements. I created the appropriate new halfedges, edges, faces, and
      vertex, and assigned all their pointers. Like Part 4, I "re-purposed" the
      original edge (<i>b</i>, <i>c</i>), this time to become (<i>b</i>,
      <i>m</i>), and faces (<i>a</i>, <i>b</i>, <i>c</i>) and (<i>b</i>,
      <i>c</i>, <i>d</i>) became (<i>a</i>, <i>b</i>, <i>m</i>) and (<i>b</i>,
      <i>d</i>, <i>m</i>) respectively. For the position of <i>m</i>, I added
      the positions of <i>a</i>, <i>b</i>, <i>c</i>, and <i>d</i>, and then
      divided this sum by 4.
    </p>
    <p>
      Errors I encountered here were also related to incorrect pointer
      assignments in my original attempt, usually to do with assigning to the
      correct new face and keeping in mind the anti-clockwise direction of the
      half-edges, since I didn't redraw the diagram. I debugged this again
      mostly through carefully re-reading my pointer assignments.
    </p>

    <br /><br />
    <div>
      <img src="./p15.png" width="95%" id="figure" />
      <figcaption>
        Screenshot of <code>dae/teapot.dae</code> before edge splits/flips
      </figcaption>
    </div>
    <div>
      <img src="./p16.png" width="95%" id="figure" />
      <figcaption>
        Screenshot of <code>dae/teapot.dae</code> with some edge splits
      </figcaption>
    </div>
    <div>
      <img src="./p17.png" width="95%" id="figure" />
      <figcaption>
        Screenshot of <code>dae/teapot.dae</code> with some edge splits and
        flips
      </figcaption>
    </div>
    <br />
    <br />

    <h2>Part 6: Loop Subdivision for Mesh Upsampling</h2>
    <p></p>
    <p></p>

    <br /><br />
    <div id="row">
      <div>
        <img src="./task5-1.png" width="350px" id="figure" />
        <figcaption>[REPLACE] L_ZERO and P_NEAREST</figcaption>
      </div>
      <div>
        <img src="./task5-2.png" width="350px" id="figure" />
        <figcaption>[REPLACE] L_ZERO and P_LINEAR</figcaption>
      </div>
    </div>
    <br /><br />
    <div id="row">
      <div>
        <img src="./task5-1.png" width="350px" id="figure" />
        <figcaption>[REPLACE] L_NEAREST and P_NEAREST</figcaption>
      </div>
      <div>
        <img src="./task5-2.png" width="350px" id="figure" />
        <figcaption>[REPLACE] L_NEAREST and P_LINEAR</figcaption>
      </div>
    </div>
  </body>
</html>
